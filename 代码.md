### 代码

#### button.h

```c++
// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef UI_VIEWS_CONTROLS_BUTTON_BUTTON_H_
#define UI_VIEWS_CONTROLS_BUTTON_BUTTON_H_

#include "ui/views/view.h"
//使用views的命名空间
namespace views { 
//前置声明Button类和Event类
class Button;
class Event;

// An interface implemented by an object to let it know that a button was
// pressed.
//按钮监听类，基类，只写了按钮按压的纯虚函数
class VIEWS_EXPORT ButtonListener {
 public:
  virtual void ButtonPressed(Button* sender, const ui::Event& event) = 0;

 protected:
  virtual ~ButtonListener() {}
};

// A View representing a button. Depending on the specific type, the button
// could be implemented by a native control or custom rendered.
   //button按钮继承自view类，扩展了按钮状态，按钮风格
class VIEWS_EXPORT Button : public View {
 public:
  virtual ~Button();
  //按钮状态
  // Button states for various button sub-types.
  enum ButtonState {
    STATE_NORMAL = 0,
    STATE_HOVERED,
    STATE_PRESSED,
    STATE_DISABLED,
    STATE_COUNT,
  };
  //按钮风格
  // Button styles with associated images and border painters.
  // TODO(msw): Add Menu, ComboBox, etc.
  enum ButtonStyle {
    STYLE_BUTTON = 0,
    STYLE_TEXTBUTTON,
    STYLE_NATIVE_TEXTBUTTON,
    STYLE_COUNT,
  };
	//设置工具提示文本
  void SetTooltipText(const string16& tooltip_text);
	//返回标记
  int tag() const { return tag_; } 
    //设置标记
  void set_tag(int tag) { tag_ = tag; } 
	//设置访问名
  void SetAccessibleName(const string16& name); 

  // Overridden from View:  重写view的函数
    
  //是否可以得到工具提示文本
  virtual bool GetTooltipText(const gfx::Point& p,
                              string16* tooltip) const OVERRIDE;
    
  //得到访问状态
  virtual void GetAccessibleState(ui::AccessibleViewState* state) OVERRIDE;

 protected:
  // Construct the Button with a Listener. The listener can be NULL. This can be
  // true of buttons that don't have a listener - e.g. menubuttons where there's
  // no default action and checkboxes.
  explicit Button(ButtonListener* listener);

  // Cause the button to notify the listener that a click occurred.
  //通知点击发生
  virtual void NotifyClick(const ui::Event& event);

  // The button's listener. Notified when clicked.
  //监听器对象指针
  ButtonListener* listener_;

 private:
  // The text shown in a tooltip.
  string16 tooltip_text_; //工具提示文本信息

  // Accessibility data.
  string16 accessible_name_;//访问名

  // The id tag associated with this button. Used to disambiguate buttons in
  // the ButtonListener implementation.
  int tag_; //标记

  //禁用赋值和拷贝函数
  DISALLOW_COPY_AND_ASSIGN(Button);
};

}  // namespace views

#endif  // UI_VIEWS_CONTROLS_BUTTON_BUTTON_H_

```

#### button.cc

```c++
// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "ui/views/controls/button/button.h"

#include "base/strings/utf_string_conversions.h"
#include "ui/base/accessibility/accessible_view_state.h"

namespace views {

////////////////////////////////////////////////////////////////////////////////
// Button, public:

Button::~Button() {
}

void Button::SetTooltipText(const string16& tooltip_text) {
  tooltip_text_ = tooltip_text;
  if (accessible_name_.empty())
    accessible_name_ = tooltip_text_;
  TooltipTextChanged();
}

void Button::SetAccessibleName(const string16& name) {
  accessible_name_ = name;
}

////////////////////////////////////////////////////////////////////////////////
// Button, View overrides:

bool Button::GetTooltipText(const gfx::Point& p, string16* tooltip) const {
  if (tooltip_text_.empty())
    return false;

  *tooltip = tooltip_text_;
  return true;
}

void Button::GetAccessibleState(ui::AccessibleViewState* state) {
  state->role = ui::AccessibilityTypes::ROLE_PUSHBUTTON;
  state->name = accessible_name_;
}

////////////////////////////////////////////////////////////////////////////////
// Button, protected:

Button::Button(ButtonListener* listener)
    : listener_(listener),
      tag_(-1) {
  set_accessibility_focusable(true);
}

void Button::NotifyClick(const ui::Event& event) {
  // We can be called when there is no listener, in cases like double clicks on
  // menu buttons etc.
  if (listener_)
    listener_->ButtonPressed(this, event);
}

}  // namespace views

```

#### custom_button.h

custom_button类继承自button类和animationdelegate（动画代理、代表）

```c++
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef UI_VIEWS_CONTROLS_BUTTON_CUSTOM_BUTTON_H_
#define UI_VIEWS_CONTROLS_BUTTON_CUSTOM_BUTTON_H_

#include "base/memory/scoped_ptr.h"
#include "ui/base/animation/animation_delegate.h"
#include "ui/base/events/event_constants.h"
#include "ui/views/controls/button/button.h"

namespace ui {
class ThrobAnimation;
}

namespace views {

class CustomButtonStateChangedDelegate;
//按钮通常是不聚焦的，也不在聚焦链里，可以用set_focusable(true) 函数让它在聚焦链里
// A button with custom rendering. The common base class of ImageButton and
// TextButton.
// Note that this type of button is not focusable by default and will not be
// part of the focus chain.  Call set_focusable(true) to make it part of the
// focus chain.
//双继承自button和animationDelegate(动画代表)
class VIEWS_EXPORT CustomButton : public Button,
                                  public ui::AnimationDelegate {
 public:
  //kviewclassname是菜单按钮的类名
  // The menu button's class name.
  static const char kViewClassName[];

  virtual ~CustomButton();
  //得到/设置当前按钮的状态
  // Get/sets the current display state of the button.
  ButtonState state() const { return state_; }
  void SetState(ButtonState state);
  //开始跳动，看看悬停动画
  // Starts throbbing. See HoverAnimation for a description of cycles_til_stop.
  void StartThrobbing(int cycles_til_stop);
  //立即停止跳动
  // Stops throbbing immediately.
  void StopThrobbing();
  //设置悬停动画持续时间
  // Set how long the hover animation will last for.
  void SetAnimationDuration(int duration);
  //设置触发事件的flag
  void set_triggerable_event_flags(int triggerable_event_flags) {
    triggerable_event_flags_ = triggerable_event_flags;
  }
  //得到触发事件flag的值
  int triggerable_event_flags() const { return triggerable_event_flags_; }
  //设置是否在鼠标按压时调用请求焦点， 默认调用
  // Sets whether |RequestFocus| should be invoked on a mouse press. The default
  // is true.
  void set_request_focus_on_press(bool value) {
    request_focus_on_press_ = value;
  }
  bool request_focus_on_press() const { return request_focus_on_press_; }
  //设置动画是否展示，在按钮状态改变的时候
  // See description above field.
  void set_animate_on_state_change(bool value) {
    animate_on_state_change_ = value;
  }
  //设置热跟踪
  void SetHotTracked(bool is_hot_tracked);
  //返回是否设置了热跟踪
  bool IsHotTracked() const;
  //重写view的函数
  // Overridden from View:
  virtual void OnEnabledChanged() OVERRIDE;
  virtual const char* GetClassName() const OVERRIDE;
  virtual bool OnMousePressed(const ui::MouseEvent& event) OVERRIDE;
  virtual bool OnMouseDragged(const ui::MouseEvent& event) OVERRIDE;
  virtual void OnMouseReleased(const ui::MouseEvent& event) OVERRIDE;
  virtual void OnMouseCaptureLost() OVERRIDE;
  virtual void OnMouseEntered(const ui::MouseEvent& event) OVERRIDE;
  virtual void OnMouseExited(const ui::MouseEvent& event) OVERRIDE;
  virtual void OnMouseMoved(const ui::MouseEvent& event) OVERRIDE;
  virtual bool OnKeyPressed(const ui::KeyEvent& event) OVERRIDE;
  virtual bool OnKeyReleased(const ui::KeyEvent& event) OVERRIDE;
  virtual void OnGestureEvent(ui::GestureEvent* event) OVERRIDE;
  virtual bool AcceleratorPressed(const ui::Accelerator& accelerator) OVERRIDE;
  virtual void ShowContextMenu(const gfx::Point& p,
                               ui::MenuSourceType source_type) OVERRIDE;
  virtual void OnDragDone() OVERRIDE;
  virtual void GetAccessibleState(ui::AccessibleViewState* state) OVERRIDE;
  virtual void VisibilityChanged(View* starting_from, bool is_visible) OVERRIDE;

  // Overridden from ui::AnimationDelegate:
  virtual void AnimationProgressed(const ui::Animation* animation) OVERRIDE;
  //拿代理所有权
  // Takes ownership of the delegate.
  void set_state_changed_delegate(CustomButtonStateChangedDelegate* delegate) {
    state_changed_delegate_.reset(delegate);
  }

 protected:
  //使用监听器构建这个按钮
  // Construct the Button with a Listener. See comment for Button's ctor.
  explicit CustomButton(ButtonListener* listener);

  //当setstatus()函数通过一个不同于当前状态的值，这个函数(statuschanged)被调用。这个方法提供给子类在状态改变时做一些事
  // Invoked from SetState() when SetState() is passed a value that differs from
  // the current state. CustomButton's implementation of StateChanged() does
  // nothing; this method is provided for subclasses that wish to do something
  // on state changes.
  virtual void StateChanged();

  //返回true如果事件可以触发通知监听器
  // Returns true if the event is one that can trigger notifying the listener.
  //返回true，如果鼠标左键被按下
  // This implementation returns true if the left mouse button is down.
  virtual bool IsTriggerableEvent(const ui::Event& event);

  // Returns true if the button should become pressed when the user
  // holds the mouse down over the button. For this implementation,
  // we simply return IsTriggerableEvent(event).
  virtual bool ShouldEnterPushedState(const ui::Event& event);

  // Overridden from View:
  virtual void ViewHierarchyChanged(
      const ViewHierarchyChangedDetails& details) OVERRIDE;
  virtual void OnBlur() OVERRIDE;
  //按钮状态
  // The button state (defined in implementation)
  ButtonState state_;

  // Hover animation.
  scoped_ptr<ui::ThrobAnimation> hover_animation_;

 private:
  //是否展示动画当状态改变时 默认是展示的
  // Should we animate when the state changes? Defaults to true.
  bool animate_on_state_change_;
  //覆盖动画是否在startthrob被调用是运行
  // Is the hover animation running because StartThrob was invoked?
  bool is_throbbing_;
  //鼠标事件标志(可以触发按钮动作)
  // Mouse event flags which can trigger button actions.
  int triggerable_event_flags_;

  // See description above setter.
  bool request_focus_on_press_;

  scoped_ptr<CustomButtonStateChangedDelegate> state_changed_delegate_;

  DISALLOW_COPY_AND_ASSIGN(CustomButton);
};

// Delegate for actions taken on state changes by CustomButton.
class VIEWS_EXPORT CustomButtonStateChangedDelegate {
public:
  virtual ~CustomButtonStateChangedDelegate() {}
  virtual void StateChanged(Button::ButtonState state) = 0;

protected:
  CustomButtonStateChangedDelegate() {}

private:
  DISALLOW_COPY_AND_ASSIGN(CustomButtonStateChangedDelegate);
};

}  // namespace views

#endif  // UI_VIEWS_CONTROLS_BUTTON_CUSTOM_BUTTON_H_

```

